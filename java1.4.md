# java (四)

### 一、java Scanner 类

通过 Scanner 类来获取用户的输入，通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据

```
  Scanner s = new Scanner(System.in);
```

##### 1. next() 与 nextLine() 区别

next()

- 一定要读取到有效字符后才可以结束输入
- 对输入有效字符之前遇到的空白，next() 方法会自动将其去掉
- 只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符
- next() 不能得到带有空格的字符串

nextLine()

- 以Enter为结束符，也就是说 nextLine()方法返回的是输入回车之前的所有字符
- 可以获得空白

##### 2. Console类

```
  Console cons = System.console();
  String username = cons.readline("User name: ");
  char[] passwd = cons.readPassword("Password: ");
```

为了安全起见，返回的密码存放在一维字符数组中，而不是字符串中。在对密码进行处理之后，应该马上用一个填充值覆盖数组元素

采用Console对象处理输入不如采用Scanner方便。每次只能读取一行输入，而没有能够读取一个单词或者一个数值的方法

### 二、java 异常处理

##### 1. 原因

- 用户输入了非法数据
- 要打开的文件不存在
- 网络通信时连接中断，或者JVM内存溢出

##### 2. 异常类型

- 检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略

- 运行时异常：运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略

- 错误：错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的

  > 检查性异常: 不处理编译不能通过
  >
  > 非检查性异常:不处理编译可以通过，如果有抛出直接抛到控制台
  >
  > 运行时异常: 就是非检查性异常
  >
  > 非运行时异常: 就是检查性异常

##### 3.Exception 类的层次

所有的异常类是从 java.lang.Exception 类继承的子类,Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error ，Error 用来指示运行时环境发生的错误，异常类有两个主要的子类：IOException 类和 RuntimeException 类

##### 4. 捕获异常

使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。try/catch代码块中的代码称为保护代码

```
  try
  {
     // 程序代码
  }catch(ExceptionName e1)
  {
     //Catch 块
  }
```

##### 5. 多重捕获块

```
  try{
     // 程序代码
  }catch(异常类型1 异常的变量名1){
    // 程序代码
  }catch(异常类型2 异常的变量名2){
    // 程序代码
  }catch(异常类型2 异常的变量名2){
    // 程序代码
  }
```

##### 6. throws/throw关键字

如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部，也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的

##### 7. finally关键字

finally 关键字用来创建在 try 代码块后面执行的代码块。无论是否发生异常，finally 代码块中的代码总会被执行。在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。finally 代码块出现在 catch 代码块最后

```
  try{
    // 程序代码
  }catch(异常类型1 异常的变量名1){
    // 程序代码
  }catch(异常类型2 异常的变量名2){
    // 程序代码
  }finally{
    // 程序代码
  }
```

注：

- catch 不能独立于 try 存在
- 在 try/catch 后面添加 finally 块并非强制性要求的
- try 代码后不能既没 catch 块也没 finally 块
- try, catch, finally 块之间不能添加任何代码

##### 8.声明自定义异常

- 所有异常都必须是 Throwable 的子类
- 如果希望写一个检查性异常类，则需要继承 Exception 类
- 如果你想写一个运行时异常类，那么需要继承 RuntimeException 类

```
  class MyException extends Exception{
  }
```

##### 9. 通用异常

- JVM异常：由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类
- 程序级异常：由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类

### 三、java 继承

继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为

`class 父类 { }  class 子类 extends 父类 { }`

需要注意的是 Java 不支持多继承，但支持多重继承

###### 1. 继承的特性

- 子类拥有父类非 private 的属性、方法
- 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展
- 子类可以用自己的方式实现父类的方法
- Java 的继承是单继承，但是可以多重继承
- 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）

##### 2. 继承关键字

继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 **java.lang** 包中，所以不需要 **import**）祖先类

1. extends关键字
2. implements关键字：使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）
3. super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类
4. this关键字：指向自己的引用
5. final关键字：final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写

注：实例变量也可以被定义为 final，被定义为 final 的变量不能被修改。被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final

##### 3. 构造器

子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 **super** 关键字调用父类的构造器并配以适当的参数列表。

如果父类构造器没有参数，则在子类的构造器中不需要使用 **super** 关键字调用父类构造器，系统会自动调用父类的无参构造器

### 四、java 重写(Override)与重载(Overload)

##### 1. 重写

重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变，重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常

##### 2. 重写规则

1. 参数列表与被重写方法的参数列表必须完全相同
2. 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类
3. 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected
4. 父类的成员方法只能被它的子类重写
5. 声明为 final 的方法不能被重写
6. 声明为 static 的方法不能被重写，但是能够被再次声明
7. 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。
8. 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法
9. 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
10. 构造方法不能被重写
11. 如果不能继承一个类，则不能重写该类的方法

##### 3. super关键字的使用

当需要在子类中调用父类的被重写方法时，要使用 super 关键字

##### 4. 重载

重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表

##### 5. 重载规则

- 被重载的方法必须改变参数列表(参数个数或类型不一样)
- 被重载的方法可以改变返回类型
- 被重载的方法可以改变访问修饰符
- 被重载的方法可以声明新的或更广的检查异常
- 方法能够在同一个类中或者在一个子类中被重载
- 无法以返回值类型作为重载函数的区分标

##### 6. 重写与重载之间的区别

| 区别点   | 重写                                           | 重载     |
| -------- | ---------------------------------------------- | -------- |
| 返回类型 | 一定不能修改                                   | 可以修改 |
| 异常     | 可以减少或删除，一定不能跑出新的或者更广的异常 | 可以修改 |
| 访问     | 一定不能做严格的限制(可以降低限制)             | 可以修改 |
| 参数列表 | 一定不能修改                                   | 必须修改 |

### 五、java 多态

多态是同一个行为具有多个不同表现形式或形态的能力。多态就是同一个接口，使用不同的实例而执行不同操作

##### 1. 优点

1. 消除类型之间的耦合关系
2. 可替换性
3. 可扩充性
4. 接口性
5. 灵活性
6. 简化性

##### 2. 必要条件

- 继承
- 重写
- 父类引用指向子类对象

当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法

##### 3. 实现方式

1. 重写
2. 接口
3. 抽象类和抽象方法

### 六、java 抽象类

